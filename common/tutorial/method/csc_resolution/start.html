<!DOCTYPE html>
<html lang="en" dir="ltr" class="no-js">
<head>
    <meta charset="utf-8" />
    <title>tutorial:method:csc_resolution:start - Workcraft</title>
    <script>(function(H){H.className=H.className.replace(/\bno-js\b/,'js')})(document.documentElement)</script>
    <meta name="generator" content="DokuWiki"/>
<meta name="theme-color" content="#008800"/>
<meta name="robots" content="index,follow"/>
<meta name="keywords" content="tutorial,method,csc_resolution,start"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../lib/exe/opensearch.html" title="Workcraft"/>
<link rel="start" href="start.html"/>
<link rel="contents" href="start.html" title="Sitemap"/>
<link rel="manifest" href="../../lib/exe/manifest.html"/>
<link rel="alternate" type="application/rss+xml" title="Changes" />
<link rel="alternate" type="application/rss+xml" title="Current namespace" />
<link rel="edit" title="Edit this page" href="start.html"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="../../_export/xhtml/tutorial/method/csc_resolution/start.xhtml"/>
<link rel="alternate" type="text/plain" title="Wiki Markup" href="../../_export/raw/tutorial/method/csc_resolution/start.raw"/>
<link rel="canonical" href="https://workcraft.org/tutorial/method/csc_resolution/start"/>
<link rel="stylesheet" href="../../lib/exe/css.php.t.dokuwiki-light-export.css"/>
<!--[if gte IE 9]><!-->
<script >/*<![CDATA[*/var NS='tutorial:method:csc_resolution';var SIG=" --- \/\/[[support@workcraft.org| ]] 2020\/11\/24 09:02\/\/";var JSINFO = {"fastwiki":{"secedit":1,"preview":1,"fastpages":1,"save":0,"fastshow":0,"fastshow_same_ns":1,"fastshow_include":"","fastshow_exclude":"","preload":false,"preload_head":"====47hsjwycv782nwncv8b920m8bv72jmdm3929bno3b3====","preload_batchsize":false,"preload_per_page":false,"locktime":840,"usedraft":1,"text_btn_show":"Show page","templatename":"dokuwiki-light-export"},"plugin_folded":{"hide":"hide","reveal":"reveal"},"move_renameokay":true,"id":"tutorial:method:csc_resolution:start","namespace":"tutorial:method:csc_resolution","ACT":"show","useHeadingNavigation":0,"useHeadingContent":0};
/*!]]>*/</script>
<script charset="utf-8" src="../../lib/exe/jquery.php.t.dokuwiki-light-export.js" defer="defer"></script>
<script charset="utf-8" src="../../lib/exe/js.php.t.dokuwiki-light-export.js" defer="defer"></script>
<!--<![endif]-->
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="shortcut icon" href="../../favicon.ico" />
<link rel="apple-touch-icon" href="../../apple-touch-icon.png" />
    </head>

<body>
    <div id="dokuwiki__site"><div id="dokuwiki__top" class="site dokuwiki mode_show tpl_dokuwiki-light-export loggedIn    ">

        
<!-- ********** HEADER ********** -->
<div id="dokuwiki__header"><div class="pad group">

    
    <div class="headings group">
        <h1><a href="../../start.html"  accesskey="" title=""><img src="../../logo.png" width="381" height="64" alt="" /></a></h1>
            </div>

    <div class="tools group">
        <!-- USER TOOLS -->
<!--
                    <div id="dokuwiki__usertools">
                <h3 class="a11y">User Tools</h3>
                <ul>
                    <li class="action profile"><a href="start.html" title="Profile" rel="nofollow"><span>Profile</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M2 3h20c1.05 0 2 .95 2 2v14c0 1.05-.95 2-2 2H2c-1.05 0-2-.95-2-2V5c0-1.05.95-2 2-2m12 3v1h8V6h-8m0 2v1h8V8h-8m0 2v1h7v-1h-7m-6 3.91C6 13.91 2 15 2 17v1h12v-1c0-2-4-3.09-6-3.09M8 6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3z"/></svg></a></li><li class="action admin"><a href="start.html" title="Admin" rel="nofollow"><span>Admin</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 15.5A3.5 3.5 0 0 1 8.5 12 3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.64.07-.97 0-.33-.03-.66-.07-1l2.11-1.63c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.39-1.06-.73-1.69-.98l-.37-2.65A.506.506 0 0 0 14 2h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.59-1.69.98l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.34-.07.67-.07 1 0 .33.03.65.07.97l-2.11 1.66c-.19.15-.25.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1.01c.52.4 1.06.74 1.69.99l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.37-2.65c.63-.26 1.17-.59 1.69-.99l2.49 1.01c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.66z"/></svg></a></li><li class="action logout"><a href="start.html" title="Log Out" rel="nofollow"><span>Log Out</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M17 17.25V14h-7v-4h7V6.75L22.25 12 17 17.25M13 2a2 2 0 0 1 2 2v4h-2V4H4v16h9v-4h2v4a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9z"/></svg></a></li>                </ul>
            </div>
        -->
        <!-- SITE TOOLS -->
<!--
        <div id="dokuwiki__sitetools">
            <h3 class="a11y">Site Tools</h3>
            <form action="../../start.html" method="get" role="search" class="search doku_form" id="dw__search" accept-charset="utf-8"><input type="hidden" name="do" value="search" /><input type="hidden" name="id" value="tutorial:method:csc_resolution:start" /><div class="no"><input name="q" type="text" class="edit" title="[F]" accesskey="f" placeholder="Search" autocomplete="on" id="qsearch__in" value="" /><button value="1" type="submit" title="Search">Search</button><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>            <div class="mobileTools">
                <form action="../..//doku.html.doku.php.html" method="get" accept-charset="utf-8"><div class="no"><input type="hidden" name="id" value="tutorial:method:csc_resolution:start" /><input type="hidden" name="sectok" value="76e97b919f59bf5330d969a72ba5bf17" /><select name="do" class="edit quickselect" title="Tools"><option value="">Tools</option><optgroup label="Page Tools"><option value="edit">Edit this page</option><option value="revisions">Old revisions</option><option value="export_pdf">Export to PDF</option><option value="menuitemfolded">Fold/unfold all</option><option value="menuitem">Rename Page</option><option value="siteexport_addpage">Export Page to HTML/PDF</option><option value="backlink">Backlinks</option></optgroup><optgroup label="Site Tools"><option value="recent">Changes</option><option value="media">Media</option><option value="index">Sitemap</option></optgroup><optgroup label="User Tools"><option value="profile">Profile</option><option value="admin">Admin</option><option value="logout">Log Out</option></optgroup></select><button type="submit">&gt;</button></div></form>            </div>
            <ul>
                <li class="action recent"><a href="start.html" title="Changes [r]" rel="nofollow" accesskey="r">Changes</a></li><li class="action media"><a href="start.html" title="Media" rel="nofollow">Media</a></li><li class="action index"><a href="start.html" title="Sitemap [x]" rel="nofollow" accesskey="x">Sitemap</a></li>            </ul>
        </div>
-->
    </div>

    <!-- BREADCRUMBS -->
<!--
    -->


    <hr class="a11y" />
</div></div><!-- /header -->

        <div class="wrapper group">

            
            <!-- ********** CONTENT ********** -->
            <div id="dokuwiki__content"><div class="pad group">
                
                <div class="pageId"><span>tutorial:method:csc_resolution:start</span></div>

                <div class="page group">
                                                            <!-- wikipage start -->
                    <div class="plugin_fastwiki_marker" style="display:none"></div><!-- TOC START -->
<div id="dw__toc" class="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="#what_are_csc_conflicts">What are CSC conflicts?</a></div></li>
<li class="level1"><div class="li"><a href="#automatic_resolution_of_csc_conflicts">Automatic resolution of CSC conflicts</a></div></li>
<li class="level1"><div class="li"><a href="#manual_resolution_of_csc_conflicts_if_you_cannot_help_it">Manual resolution of CSC conflicts (if you cannot help it)</a></div></li>
<li class="level1"><div class="li"><a href="#visualisation_of_csc_conflicts">Visualisation of CSC conflicts</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="#visualisation_of_csc_conflicts_at_the_level_of_state_graphs">Visualisation of CSC conflicts at the level of state graphs</a></div></li>
<li class="level2"><div class="li"><a href="#visualisation_of_csc_conflicts_at_the_level_of_stgs">Visualisation of CSC conflicts at the level of STGs</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="#transformations_for_resolving_encoding_conflicts">Transformations for resolving encoding conflicts</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="#signal_insertion">Signal insertion</a></div></li>
<li class="level2"><div class="li"><a href="#concurrency_reduction">Concurrency reduction</a></div></li>
<li class="level2"><div class="li"><a href="#transition_reordering">Transition reordering</a></div></li>
<li class="level2"><div class="li"><a href="#making_extra_inputs_available">Making extra inputs available</a></div></li>
<li class="level2"><div class="li"><a href="#relative_timing_assumptions">Relative timing assumptions</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="#solutions">Solutions</a></div></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 id="resolution_of_encoding_csc_conflicts">Resolution of encoding (CSC) conflicts</h1>
<div class="level1">

<p>
A common issue in synthesis of speed-independent circuits from <em>Signal Transition Graphs (STGs)</em> are <em>encoding conflicts</em>, a.k.a. <em>Complete State Coding (CSC) conflicts.</em> Detection and resolution of CSC conflicts is an important part of the design process.
</p>

</div>

<h2 id="what_are_csc_conflicts">What are CSC conflicts?</h2>
<div class="level2">

<p>
CSC conflicts arise when two semantically different (i.e. enabling different output or internal signals) reachable states have the same <em>encoding,</em> i.e. the same values of all the signals. For example, consider the following <abbr title="Signal Transition Graph">STG</abbr> specifying the read phase of the <a href="../../design/vme_bus/start.html" class="wikilink1" title="tutorial:design:vme_bus:start" data-wiki-id="tutorial:design:vme_bus:start">VME bus controller</a>.
</p>

<p>
<img src="stg-vme-read.svg" width="406" height="102" class="svgscaleinsert mediacenter" alt="Read phase of the VME bus controller">
</p>

<p>
One can see the conflicting states at the level of the <em>state graph</em> of this <abbr title="Signal Transition Graph">STG</abbr>, which can be generated via the <em>Conversion→Finite State Transducer (binary-encoded) [Petrify]</em> menu, and is shown below (after manual layout). Note that the encoding of each state is given in its label (after &#039;_&#039;) with the following order of signals: <code><span style='color:red; '>dsr</span></code>, <code><span style='color:red; '>ldtack</span></code>, <code><span style='color:blue; '>d</span></code>, <code><span style='color:blue; '>dtack</span></code>, <code><span style='color:blue; '>lds</span></code>.
</p>

<p>
<img src="vme-read-sg.svg" width="557" height="445" class="svgscaleinsert mediacenter" alt="The state graph of the above VME bus controller STG">
</p>

<p>
The two highlighted states have the same encoding, 11001, but are semantically different: in one of them the circuit must produce <code><span style='color:blue; '>d+</span></code> and is not allowed to produce <code><span style='color:blue; '>lds-</span></code>, and in the other the circuit must produce <code><span style='color:blue; '>lds-</span></code> and is not allowed to produce <code><span style='color:blue; '>d+</span></code>. Since the circuit can only &#039;see&#039; the signal values but not the tokens in the <abbr title="Signal Transition Graph">STG</abbr>, these two states are indistinguishable from its point of view, and so the specification is not directly implementable – one has first to resolve this CSC conflict by transforming the <abbr title="Signal Transition Graph">STG</abbr>.
</p>

</div>

<h2 id="automatic_resolution_of_csc_conflicts">Automatic resolution of CSC conflicts</h2>
<div class="level2">

<p>
In most practical cases CSC conflicts can be resolved automatically, via the <em>Tools→Encoding conflicts→Resolve CSC conflicts [Mpsat]</em> or <em>Tools→Encoding conflicts→Resolve CSC conflicts [Petrify]</em> menu items. For the VME bus controller <abbr title="Signal Transition Graph">STG</abbr> shown above, both MPSat and Petrify happen to generate essentially the same solution:
</p>

<p>
<img src="stg-vme-read-csc.svg" width="524" height="84" class="svgscaleinsert mediacenter" alt="The modified VME bus controller STG with an additional internal signal resolving the CSC conflict">
</p>

<p>
The state graph of this <abbr title="Signal Transition Graph">STG</abbr> is shown below (after manual layout). Note that the binary encodings of the states have one extra bit now corresponding to the newly inserted signal (this is the last bit in the encodings). The two highlighted states correspond to the conflicted states of the original <abbr title="Signal Transition Graph">STG</abbr> – one can see that now their encodings differ in the last bit and so the CSC conflict disappears. Intuitively, the newly inserted signal introduces extra memory into the circuit, helping it to track its current state and disambiguate the previously conflicted states.
</p>

<p>
<img src="vme-read_resolved-sg.svg" width="544" height="445" class="svgscaleinsert mediacenter" alt="The state graph of the modified VME bus controller STG">
</p>

<p>
Once the encoding conflicts are resolved, several kinds of circuit implementations can be automatically synthesised by the Petrify or MPSat back-ends (via the <em>Synthesis</em> menu):
</p>
<ul>
<li class="level1"><div class="li"> complex-gate implementation;</div>
</li>
<li class="level1"><div class="li"> generalised C-element (gC) implementation;</div>
</li>
<li class="level1"><div class="li"> standard C implementation.</div>
</li>
</ul>

<p>
E.g. for the former, the following next-state functions for the output and internal signals are automatically derived: 
</p>
<pre class="code">[d] = csc1 ldtack; 
[dtack] = d; 
[lds] = d + csc1; 
[csc1] = dsr (ldtack&#039; + csc1);</pre>

<p>
The total number of literals in the right-hand side of these equations is 8 – this intermediate metrics is often used for evaluating the quality of the CSC resolution process before technology mapping. The circuit corresponding to these equations is shown below (after manual layout). Note that the gate with feedback implements <code><span style='color:green; '>csc1</span></code>, and that the implementation of <code><span style='color:blue; '>dtack</span></code> is a buffer gate – it&#039;s just a wire.
</p>

<p>
<img src="circuit-vme-read_resolved.svg" width="317" height="176" class="svgscaleinsert mediacenter" alt="A complex-gate implementation of VME bus controller">
</p>

</div>

<h4 id="exercise_1">Exercise 1</h4>
<div class="level4">

<p>
Download the following <abbr title="Signal Transition Graph">STG</abbr> from <a href="#refnotes:1:note1" name="refnotes:1:ref1" class="refnotes-ref note-popup">[1]</a>: <span class="wrap_download "><a href="sram-master.work" class="media mediafile mf_work" title="tutorial:method:csc_resolution:sram-master.work (9 KB)">SRAM controller (MASTER).</a> (9 KiB)</span>:
</p>

<p>
<img src="sram-master.svg" width="527" height="399" class="svgscaleinsert mediacenter" alt="STG specification of SRAM master controller">
</p>
<ul>
<li class="level1"><div class="li"> Automatically resolve the encoding conflicts in it using the <em>Tools→Encoding conflicts→Resolve CSC conflicts [MPSat]</em> and <em>Tools→Encoding conflicts→Resolve CSC conflicts [Petrify]</em> menu items. Save the results as <code>sram-master-csc-mpsat.work</code> and <code>sram-master-csc-petrify.work</code>.</div>
</li>
<li class="level1"><div class="li"> Synthesise the complex-gate implementations of these two STGs, noting the number of literals in each case (can be found in the <em>Output</em> pane or using <em>Tools→Statistics→Circuit Analysis</em> menu item).</div>
</li>
</ul>

</div>

<h2 id="manual_resolution_of_csc_conflicts_if_you_cannot_help_it">Manual resolution of CSC conflicts (if you cannot help it)</h2>
<div class="level2">

<p>
As explained above, the resolution of CSC conflicts is automated, and the tools generally do a good job. However, there are some rare situations when manual resolution is used, e.g.:
</p>
<ul>
<li class="level1"><div class="li"> for personal enlightenment you wish to learn about CSC conflicts and techniques that can be used for their resolution;</div>
</li>
<li class="level1"><div class="li"> you have a lot of time, and the process for you is more important than its outcome <img src="../../lib/images/smileys/facepalm.gif" class="icon" alt="m(" />;</div>
</li>
<li class="level1"><div class="li"> automatic resolution failed, so you have no choice;</div>
</li>
<li class="level1"><div class="li"> you are in the process of inventing a new component that is relatively small and is likely to be highly reusable, so willing to invest considerable effort and time in optimising it as much as possible;</div>
</li>
<li class="level1"><div class="li"> you are an experienced designer, and have reasons to believe that some potentially dangerous transformations like concurrency reduction may improve your circuit so considerably that you are willing to take the risk of shooting yourself in a foot.</div>
</li>
</ul>
<div class="wrap_important wrap_round wrap_center plugin_wrap" style="width: 90%;">
<p>
If you do not fall into any of the above categories, you should be content with automatic resolutions of encoding conflicts. Otherwise you are welcome to the shady world of tools&#039; internals, with many dark corners, strange heuristics, dangerous transformations, and unsavoury hacks…
</p>
</div>
<p>
For manual resolution, the conflicts have to be
</p>
<ul>
<li class="level1"><div class="li"> <strong>detected</strong> – this is fully automated;</div>
</li>
<li class="level1"><div class="li"> <strong>visualised</strong> – two kinds of visualisation are explained below: at the level of state graphs (works only for toy examples) and at the level of STGs;</div>
</li>
<li class="level1"><div class="li"> <strong>resolved</strong> – several commonly used ways of resolving CSC conflicts are briefly explained below.</div>
</li>
</ul>

</div>

<h2 id="visualisation_of_csc_conflicts">Visualisation of CSC conflicts</h2>
<div class="level2">

<p>
Workcraft supports two ways of visualising encoding conflicts:
</p>
<ul>
<li class="level1"><div class="li"> highlighting conflicting states in the state graph;</div>
</li>
<li class="level1"><div class="li"> showing <em>conflict cores</em> in the <abbr title="Signal Transition Graph">STG</abbr> <a href="#refnotes:1:note2" name="refnotes:1:ref2" class="refnotes-ref note-popup">[2]</a> <a href="#refnotes:1:note3" name="refnotes:1:ref3" class="refnotes-ref note-popup">[3]</a> <a href="#refnotes:1:note4" name="refnotes:1:ref4" class="refnotes-ref note-popup">[4]</a>. </div>
</li>
</ul>

<p>
The former approach only works for toy examples where the state graph is small enough to fit on a screen and to be comprehensible for a human. However, for more realistic examples state graphs tend to be large as the number of reachable states is often exponential in the size of the <abbr title="Signal Transition Graph">STG</abbr>, especially if the <abbr title="Signal Transition Graph">STG</abbr> has a lot of concurrency (this is the well-known <em>state space explosion</em> problem a.k.a. <em>state explosion</em> problem). The recommended visualisation technique is based on <em>conflict cores</em> – it works directly with the <abbr title="Signal Transition Graph">STG</abbr> and so is much more human-friendly.
</p>

</div>

<h3 id="visualisation_of_csc_conflicts_at_the_level_of_state_graphs">Visualisation of CSC conflicts at the level of state graphs</h3>
<div class="level3">

<p>
An example of this kind of visualisation is shown above for the VME bus controller example. The idea is to highlight the conflicted states in the state graph with the same colour (i.e. each conflicted encoding gets its own colour). To build the state graph of the <abbr title="Signal Transition Graph">STG</abbr> and highlight the conflicted states, use the <em>Conversion→Finite State Transducer (binary-encoded) [Petrify]</em> menu. 
</p>

<p>
There are two main problems with this kind of visualisation:
</p>
<ul>
<li class="level1"><div class="li"> the state graph may be too large to be of any use for a human;</div>
</li>
<li class="level1"><div class="li"> even if the state graph is of moderate size, it is difficult to see how one can transform <em>the original <abbr title="Signal Transition Graph">STG</abbr></em> to resolve the conflicts.</div>
</li>
</ul>

<p>
To illustrate these problems, consider the following examples. The following <abbr title="Signal Transition Graph">STG</abbr> specifies a 4-way paralleliser: in response to the parent handshake <code><span style='color:red; '>r</span></code> / <code><span style='color:blue; '>a</span></code> it initiates four child handshakes in parallel:
</p>

<p>
<img src="par4.svg" width="264" height="293" class="svgscaleinsert mediacenter" alt="4-way paralleliser">
</p>

<p>
Though this <abbr title="Signal Transition Graph">STG</abbr> is very small and comprehensible, due to high concurrency its state graph is large (628 states) and is of limited utility for humans:
</p>

<p>
<img src="par4-sg.svg" width="7681" height="3809" class="svgscaleinsert mediacenter" alt="State graph of 4-way paralleliser">
</p>

<p>
The following <abbr title="Signal Transition Graph">STG</abbr> specifies a part of an A2D converter <a href="#refnotes:1:note5" name="refnotes:1:ref5" class="refnotes-ref note-popup">[5]</a>.
</p>

<p>
<img src="a2d.svg" width="273" height="424" class="svgscaleinsert mediacenter" alt="Part of an A2D converter">
</p>

<p>
The corresponding state graph is not particularly large, but there are several CSC conflicts and it is not straightforward by looking at it to understate the causes of these conflicts and to find transformations resolving them:
</p>

<p>
<img src="a2d-sg.svg" width="440" height="1005" class="svgscaleinsert mediacenter" alt="Stage graph of the A2D converter STG">
</p>

</div>

<h3 id="visualisation_of_csc_conflicts_at_the_level_of_stgs">Visualisation of CSC conflicts at the level of STGs</h3>
<div class="level3">

<p>
An alternative and recommended method of visualising encoding conflicts is based on showing the <em>conflict cores</em> in the <abbr title="Signal Transition Graph">STG</abbr> <a href="#refnotes:1:note2" name="refnotes:1:ref6" class="refnotes-ref note-popup">[2]</a> <a href="#refnotes:1:note3" name="refnotes:1:ref7" class="refnotes-ref note-popup">[3]</a> <a href="#refnotes:1:note4" name="refnotes:1:ref8" class="refnotes-ref note-popup">[4]</a>. Consider the VME bus controller <abbr title="Signal Transition Graph">STG</abbr> shown above. The two conflicted states can be reached from the initial state by the following two traces:
</p>

<p>
<code><span style='color:red; '>dsr+</span>, <span style='color:blue; '>lds+</span>, <span style='color:red; '>ldtack+</span></code><br/>

<code><span style='color:red; '>dsr+</span>, <span style='color:blue; '>lds+</span>, <span style='color:red; '>ldtack+</span>, <span style='color:blue; '>d+</span>, <span style='color:blue; '>dtack+</span>, <span style='color:red; '>dsr-</span>, <span style='color:blue; '>d-</span>, <span style='color:blue; '>dtack-</span>, <span style='color:red; '>dsr+</span></code>
</p>

<p>
By taking the difference of two traces we get a set of transitions forming a <em>conflict core</em> shown below. To see it in Workcraft, use the <em>Verification→Complete State Coding (all conflicts) [MPSat]</em> menu and then select <em>Show selected cores</em> in the <em>Tool controls</em> panel.
</p>

<p>
<img src="screenshot-vme-coremap.png" class="mediacenter" title="VME bus controller: core map" alt="VME bus controller: core map" />
</p>

<p>
Note that this core has several important properties helping the user to understand the cause of the conflict and find ways to resolve it:
</p>
<ul>
<li class="level1"><div class="li"> the states (i.e. cuts in the <abbr title="Signal Transition Graph">STG</abbr>) just before and just after the core are in encoding conflict;</div>
</li>
<li class="level1"><div class="li"> the numbers of <code>s+</code> and <code>s-</code> transitions in the core are the same for each signal <code>s</code> as the states just before and just after the core have the same encoding;</div>
</li>
<li class="level1"><div class="li"> if the transformation upsets this balance of signals in the core (e.g. <span style='color:green; '>csc+</span> is inserted somewhere inside the core and <span style='color:green; '>csc-</span> is inserted somewhere outside the core) then the associated conflicts become resolved.</div>
</li>
</ul>

<p>
The core map for the 4-way paralleliser is as follows. Note that it is much more comprehensible than the state graph: Each concurrent branch has a single conflict core inside it, and one can resolve these cores e.g. by inserting the rising transitions of four new internal signals into these cores, and the corresponding falling transitions outside of these cores.
</p>
<div class="wrap_tip wrap_round wrap_center plugin_wrap" style="width: 90%;">
<p>
Each core is given a different colour. If there are several cores, it is possible to show any subset of them by selecting the required cores in the <em>Tool controls</em> panel.
</p>
</div>
<p>
<img src="screenshot-par4-coremap.png" class="mediacenter" title="4-way paralleliser: core map" alt="4-way paralleliser: core map" />
</p>

<p>
The core map corresponding to the A2D controller example is shown below on the left. Note that in this case there are five cores, some of which overlap (and so some of the transitions are highlighted with several colours as they belong to several cores). Core overlaps can be exploited during the resolution process – by inserting <code><span style='color:green; '>csc+</span></code> into the overlap of several cores one can destroy these cores, killing several birds with one stone. Furthermore, one can insert <code><span style='color:green; '>csc-</span></code> into some of the remaining cores, increasing thus the number of killed birds.
</p>

<p>
<img src="screenshot-a2d-core_and_height_map.png" class="mediacenter" title="A2D converter: Core map (left) and height map (right)" alt="A2D converter: Core map (left) and height map (right)" />
</p>

<p>
When there are multiple overlapping cores, one can quickly identify the promising areas where a signal insertion (or some other transformation) would eliminate as many encoding conflicts as possible by considering the <em>core density map</em> – for the A2D controller example it is shown above on the right. The idea is to count how many cores a transition belongs to, and the higher this number is, the darker is the shade used to highlight this transition. The analogy is with a topographic map where darker shades show higher altitudes – the &#039;peaks&#039; with the darkest shade are good areas where a single signal insertion can eliminate the maximum number of cores. E.g. in the A2D controller example the highest peak is formed by the transitions <code><span style='color:red; '>Laf+</span></code>, <code><span style='color:blue; '>Ar-</span></code>, <code><span style='color:blue; '>Lr-</span></code> and <code><span style='color:red; '>Laf-</span></code> that belong to the same four cores. Hence inserting <code><span style='color:green; '>csc+</span></code> somewhere in this peak eliminates these four cores. The remaining core can be also eliminated if <code><span style='color:green; '>csc-</span></code> is inserted into it, i.e. all the encoding conflicts in this example can be resolved by a single signal insertion.
</p>
<div class="plugin_wrap"><div class="wrap_column wrap_half plugin_wrap"><div class="table sectionedit9"><table class="inline">
	<tr class="row0">
		<td class="col0"><img src="a2d-csc-mpsat.svg" width="263" height="420" class="svgscaleinsert mediacenter" alt="tutorial:method:csc_resolution:a2d-csc-mpsat.svg"></td>
	</tr>
	<tr class="row1">
		<td class="col0 centeralign">  MPSat&#039;s solution  </td>
	</tr>
</table></div>
</div><div class="wrap_column wrap_half plugin_wrap"><div class="table sectionedit12"><table class="inline">
	<tr class="row0">
		<td class="col0"><img src="a2d-csc-petrify.svg" width="263" height="420" class="svgscaleinsert mediacenter" alt="tutorial:method:csc_resolution:a2d-csc-petrify.svg"></td>
	</tr>
	<tr class="row1">
		<td class="col0 centeralign">  Petrify&#039;s solution  </td>
	</tr>
</table></div>
</div></div>
<p>
The above STGs show two alternative signal insertions resolving all the conflicts with a single new internal signal in the A2D converter. They were derived automatically by the MPSat and Petrify back-ends, accessible via the <em>Tools→Encoding conflicts→Resolve CSC conflicts [MPSat]</em> and <em>Tools→Encoding conflicts→Resolve CSC conflicts [Petrify]</em> menu items. The complex-gate implementations corresponding to the resulting two STGs are as follows:
</p>
<pre class="code">// MPSat: 14 literals
[Ar] = (Laf&#039; + csc1&#039;) (Ad&#039; + Ar) Lam&#039;
[Lr] = Ar (Ad start csc1&#039; + Lr)
[ready] = csc1
[csc1] = start csc1 + Laf</pre>
<pre class="code">// Petrify: 15 literals
[Ar] = Laf&#039; Lam&#039; (Ar + Ad&#039;); 
[Lr] = csc0&#039; (Ad Ar start + Laf); 
[ready] = csc0 + Laf; 
[csc0] = Ar&#039; Laf + csc0 start;</pre>

<p>
Note that MPSat&#039;s solution is smaller, but Petrify&#039;s solution has more concurrency.
</p>
<div class="wrap_tip wrap_round wrap_center plugin_wrap" style="width: 90%;">
<p>
MPSat and Petrify are different back-end tools that perform the actual resolution of CSC conflicts. These tools use different methods and somewhat different cost functions, so it makes sense to try them both and then choose the solution that better fits the designer&#039;s goals (in terms of area, performance, etc.).
</p>
</div>
</div>

<h2 id="transformations_for_resolving_encoding_conflicts">Transformations for resolving encoding conflicts</h2>
<div class="level2">

<p>
Below several ways of resolving encoding conflicts are outlined. They are supported by tools, with various levels of automation. It is difficult to beat the tools on their own field, as they employ advanced techniques and use complicated cost functions that would be difficult for humans to compute. However, the human designer has information and capabilities that are not available to the tools, in particular the high-level understanding of the design, the possibility to change the contract between the circuit and the environment (and re-design the latter if required), etc. So you need to think “outside the box” to beat the tools.
</p>

</div>

<h3 id="signal_insertion">Signal insertion</h3>
<div class="level3">

<p>
Severity level: <span style='color:green; '>Paracetamol</span>
</p>

<p>
New internal signals can be added to the <abbr title="Signal Transition Graph">STG</abbr> in such a way that its external behaviour (i.e. the &#039;contract&#039; with the environment) stays unchanged. These internal signals add memory to the circuit helping it to trace its current state. The encodings of the states get longer due to the new signals, which helps to disambiguate the states that previously had the same encodings.
</p>

<p>
When inserting a new internal signal, say <code><span style='color:green; '>csc</span></code>, one has to make sure that:
</p>
<ul>
<li class="level1"><div class="li"> no input is directly delayed (triggered) by the transitions of <code><span style='color:green; '>csc</span></code>, as this is not implementable (the environment is oblivious to internal signals);</div>
</li>
<li class="level1"><div class="li"> the consistency is not violated, i.e. the rising and falling edges of <code><span style='color:green; '>csc</span></code> alternate in every execution, always starting from the same edge;</div>
</li>
<li class="level1"><div class="li"> the output persistency is not violated, i.e. <code><span style='color:green; '>csc</span></code> must not disable or be disabled by any other signal;</div>
</li>
<li class="level1"><div class="li"> <code><span style='color:green; '>csc</span></code> resolves some encoding conflicts;</div>
</li>
<li class="level1"><div class="li"> when inserting a transition, say <code><span style='color:green; '>csc-</span></code>, outside the core, make sure that it is not adjacent to the core, i.e. there are some other transitions separating the core from <code><span style='color:green; '>csc-</span></code> (otherwise the core will suck <code><span style='color:green; '>csc-</span></code> in and re-appear with both <code><span style='color:green; '>csc+</span></code> and <code><span style='color:green; '>csc-</span></code> inside it).</div>
</li>
</ul>

<p>
In addition to these, one should try to heuristically optimise the final implementation, as the way the signals are inserted affects the quality of the resulting circuit very significantly. Note, however, that “the quality of the circuit” cannot be defined at this point, as an <abbr title="Signal Transition Graph">STG</abbr> with CSC conflicts is not directly implementable. However, various heuristics for signal insertions are known to be beneficial, e.g.:
</p>
<ul>
<li class="level1"><div class="li"> increasing the number of resolved cores;</div>
</li>
<li class="level1"><div class="li"> reducing the number of transitions of <code><span style='color:green; '>csc</span></code>;</div>
</li>
<li class="level1"><div class="li"> sequential insertions of transitions of <code><span style='color:green; '>csc</span></code> often result in a smaller circuit with less concurrency, whereas concurrent insertions result in a more concurrent operation at the expense of the area (it is important to note that this more concurrent operation does not necessarily improve the performance of the circuit, as the more complicated implementation imposes additional overheads);</div>
</li>
<li class="level1"><div class="li"> reducing the number of signals triggering or triggered by <code><span style='color:green; '>csc</span></code> often leads to a simpler implementation of <code><span style='color:green; '>csc</span></code> and those signals, as the trigger<strong>ing</strong> signals are always in the support of the gate implementing the trigger<strong>ed</strong> signal (e.g. one can try replacing one or more triggers of some signal by <code><span style='color:green; '>csc</span></code>, rather than adding <code><span style='color:green; '>csc</span></code> as an extra trigger);</div>
</li>
<li class="level1"><div class="li"> <em>locking</em> <code><span style='color:green; '>csc</span></code> with some existing signals (two signals are called <em>locked</em> if their transitions alternate in every execution).</div>
</li>
</ul>

<p>
Examples and techniques for signal insertion have already been presented above. Considerations when using signal insertion:
</p>
<ul>
<li class="level1"><div class="li"> behaviour is preserved and so the contract with the environment stays the same <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;</div>
</li>
<li class="level1"><div class="li"> inserted signals have to be implemented, i.e. the logic becomes more complicated <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />.</div>
</li>
</ul>
<div class="wrap_tip wrap_round wrap_center plugin_wrap" style="width: 90%;">
<p>
When trying to resolve encoding conflicts by signal insertion you will be competing with the tools on their own field (as the contract with the environment is unchanged, no insight that is not already available to the tool is exploited), and so are unlikely to significantly improve the automatically generated solution. As an example, consider the (very simple) VME bus controller <abbr title="Signal Transition Graph">STG</abbr> above. MPSat backend reports 18 (!) different ways of resolving the encoding conflict by inserting a single signal, and heuristically chooses the best one. How many of these can you find? For more complicated examples the number of ways to insert a signal grows very fast, and the tool will have an edge over the human designer.
</p>
</div>
</div>

<h4 id="exercise_2">Exercise 2</h4>
<div class="level4">

<p>
For the <abbr title="Signal Transition Graph">STG</abbr> in <a href="start.html#exercise_1" class="wikilink1" title="tutorial:method:csc_resolution:start" data-wiki-id="tutorial:method:csc_resolution:start">Exercise 1</a>:
</p>
<ul>
<li class="level1"><div class="li"> Visualise the conflicts using the <em>Verification→Complete State Coding (all cores) [MPSat]</em> menu item.</div>
</li>
<li class="level1"><div class="li"> Meditate on the cores map and the core density map until you understand the causes of the encoding conflicts.</div>
</li>
<li class="level1"><div class="li"> Manually resolve the encoding conflicts by signal insertion as explained above. Make sure that the essential <abbr title="Signal Transition Graph">STG</abbr> correctness properties (consistency, deadlock freeness, input properness, output persistency, and mutex implementability) are still satisfied (these can be checked via <em>Verification→Consistency, deadlock freeness, input properness, output persistency, and mutex implementability (reuse unfolding) [MPSat]</em> menu item).</div>
</li>
<li class="level1"><div class="li"> After all the conflicts are resolved, synthesise the complex-gate implementation using the <em>Synthesis→Complex gate [MPSat]</em> menu item.</div>
</li>
<li class="level1"><div class="li"> Compare the number of literals in your solution with those in Exercise 1. If yours is significantly worse, repeat the previous two steps inserting signals differently, until you are either happy with your solution or frustrated and cannot be bothered any more.</div>
</li>
</ul>

</div>

<h4 id="butterfly_construction">Butterfly construction</h4>
<div class="level4">

<p>
Occasionally the <abbr title="Signal Transition Graph">STG</abbr> has a pair of very loosely coupled handshakes, which result in difficult to resolve CSC conflicts. In such a case, one can use <em>concurrency reduction</em> (see below) to solve the CSC conflicts (or at least to reduce the number of conflict cores), but it is not always possible (e.g. the high concurrency is required, and so the handshakes cannot be coupled any tighter). Consider the following <abbr title="Signal Transition Graph">STG</abbr> (a.k.a. ‘butterfly’):
</p>

<p>
<img src="butterfly.svg" width="146" height="179" class="svgscaleinsert mediacenter" alt="Butterfly STG (template)">
</p>

<p>
It should be viewed as a template, i.e. in practice these handshakes would be loaded with some useful work. The difficulty here is that there are very few places where signal insertion is possible (note that one must not delay inputs). The automatic signal insertion is likely to either fail or yield a bad solution for such examples, as the tools insert signals one-by-one, whereas the recommended solution below depends on the interplay of a pair of internal signals:
</p>

<p>
<img src="butterfly-csc.svg" width="146" height="231" class="svgscaleinsert mediacenter" alt="Butterfly STG solution (template)">
</p>

<p>
Again, this is just a template solution that can be applied when you have loosely coupled handshakes and concurrency reduction is not applicable for some reason.
</p>

</div>

<h3 id="concurrency_reduction">Concurrency reduction</h3>
<div class="level3">

<p>
Severity level: <span style='color:orange; '>Antibiotic</span>
</p>

<p>
Another commonly used transformation for resolving CSC conflicts is <em>concurrency reduction</em> (CR) <a href="#refnotes:1:note6" name="refnotes:1:ref9" class="refnotes-ref note-popup">[6]</a>. The idea is to sequentialise some concurrent transitions in the <abbr title="Signal Transition Graph">STG</abbr> by introducing new arcs, in such a way that some of the conflicted states become unreachable. This may or may not decrease the performance: note that the loss of concurrency may be more than offset by simpler logic in some cases.
</p>
<div class="wrap_important wrap_center wrap_round plugin_wrap" style="width: 90%;">
<p>
This transformation may change the behaviour of the <abbr title="Signal Transition Graph">STG</abbr> in significant ways, and break the contract with the environment! It is up to the designer to ensure that the modified <abbr title="Signal Transition Graph">STG</abbr> still makes sense, and that the environment either can cope with the changed contract or is re-designed for the modified contract – the tools do not have sufficient information / capability to make these kinds of decisions.
</p>
</div>
<p>
A possible CR resolving the encoding conflict in the VME bus controller is shown below. The amber arc orders two previously concurrent <abbr title="Signal Transition Graph">STG</abbr> transitions, pulling <code><span style='color:blue; '>lds-</span></code> into the core, which breaks the balance and destroys the core.
</p>

<p>
<img src="stg-vme-read-cr-benign.svg" width="406" height="102" class="svgscaleinsert mediacenter" alt="VME bus controller: resolving the CSC conflict by concurrency reduction">
</p>
<div class="wrap_center wrap_round wrap_tip plugin_wrap" style="width: 90%;">
<p>
The semantics of CR arcs coincides with that of usual arcs, but it is convenient for the designer to see which arcs were original and which were added later for various technical reasons, so CR arcs are highlighted as thick amber arcs.
</p>
</div>
<p>
The state graph after this CR is shown below: Two of the formerly reachable states have become unreachable (they are faded out in the picture). One of these states used to be involved in an encoding conflict, and so eliminating this state resolves the conflict. 
</p>

<p>
<img src="vme-read-cr-sg.svg" width="557" height="445" class="svgscaleinsert mediacenter" alt="The state graph of the VME bus controller STG after concurrency reduction">
</p>

<p>
The resulting complex-gate implementation has 10 literals, which happens to be worse than the solution obtained using signal insertion.
</p>
<pre class="code">[d] = ldtack dsr lds; 
[dtack] = dtack lds + d; 
[lds] = dsr (lds + ldtack&#039;) + d; </pre>

<p>
However, often CR results in smaller circuits than signal insertion as for the latter the newly inserted signals have to be implemented.
</p>

<p>
We distinguish a special kind of <em>innocuous</em> CRs, which do not introduce any extra causal dependencies on the inputs, i.e. if the original <abbr title="Signal Transition Graph">STG</abbr> could produce some output at some state, the modified <abbr title="Signal Transition Graph">STG</abbr> in the corresponding state will be able to produce this output too, perhaps after firing some other outputs first, but <em>without waiting for any inputs from the environment.</em> For example, suppose the original <abbr title="Signal Transition Graph">STG</abbr> at some state could produce outputs <code><span style='color:blue; '>o1</span></code> and <code><span style='color:blue; '>o2</span></code> concurrently, i.e. in any order, and the applied CR fixes this order to <code><span style='color:blue; '>o1</span></code> → <code><span style='color:blue; '>o2</span></code>. Since the original environment was prepared to receive these outputs in any order, fixing the order will do no harm. In other words, innocuous CRs modify the contract with the environment in a safe way: they do not make any extra assumptions about the environment, but provide more guarantees to it (about the order of transitions). Hence, the modified <abbr title="Signal Transition Graph">STG</abbr> will work correctly in any environment in which the original <abbr title="Signal Transition Graph">STG</abbr> would have worked correctly. 
<span class="wrap_important ">
All the other CRs are called <em>risky</em> – they require extra assumptions about the environment and have to be vetted by both the designer of the <abbr title="Signal Transition Graph">STG</abbr> and the designer of the environment.
</span>
</p>

<p>
For example, the CR used in the VME bus controller <abbr title="Signal Transition Graph">STG</abbr> above is innocuous: since the environment formerly was prepared to receive <code><span style='color:blue; '>lds-</span></code> and <code><span style='color:blue; '>dtack-</span></code> in any order, fixing this order to <code><span style='color:blue; '>lds-</span></code> → <code><span style='color:blue; '>dtack-</span></code> is harmless. An alternative (and highly problematic!) way to apply CR to resolve the conflict in VME bus controller is shown below. 
</p>
<div class="wrap_center wrap_round wrap_alert plugin_wrap" style="width: 90%;">
<p>
<img src="stg-vme-read-cr-malignant.svg" width="406" height="102" class="svgscaleinsert mediacenter" alt="VME bus controller: resolving the CSC conflict by concurrency reduction">
</p>

<p>
This CR is <em>risky</em> (i.e. not <em>innocuous</em> according to the above definition) as it changes the contract with the environment in a dangerous way: the modified <abbr title="Signal Transition Graph">STG</abbr> waits for the environment to supply <code><span style='color:red; '>ldtack-</span></code> before it can produce <code><span style='color:blue; '>dtack-</span></code>. If the environment in turn waits for <code><span style='color:blue; '>dtack-</span></code> before sending <code><span style='color:red; '>ldtack-</span></code> (e.g. because the designer next-door used a risky CR to resolve some encoding conflicts in the environment without checking with you <img src="../../lib/images/smileys/icon_wink.gif" class="icon" alt=";-)" />), a deadlock ensues.
</p>

<p>
However, even if no deadlock has been introduced, there is a higher-level problem with this CR, which cannot be automatically detected even in principle: The applied CR pulls both <code><span style='color:blue; '>lds-</span></code> and <code><span style='color:red; '>ldtack-</span></code> into the core, which completely sequentialises the behaviour (the transitions become totally ordered) and <em>destroys the VME bus controller&#039;s purpose in life</em> (which is to ensure concurrent operation of the bus and the device interacting with the controller).
</p>

<p>
The complex-gate implementation below has only 7 literals, which is smaller than any of the implementations above, but, as explained, it is totally useless (other then as an illustration of CR pitfalls) and even dangerous due to the subtlety of the problem: It does look attractive and passes all the formal verification checks – so it is very easy even for an experienced designer to be seduced and damned (along with innocent colleagues) to many hours of hard labour trying to track down the cause of performance deterioration in the overall system to this pesky little circuit. Thus be on your guard against risky CRs, and firmly reject them unless explicitly approved by your <del>priest</del> line manager!
</p>
<pre class="code">[d] = dsr ldtack; 
[dtack] = dtack ldtack + d; 
[lds] = d + dsr;</pre>
</div>
<p>
The following two schematic pictures show how to resolve encoding conflicts using CRs <a href="#refnotes:1:note3" name="refnotes:1:ref10" class="refnotes-ref note-popup">[3]</a> <a href="#refnotes:1:note4" name="refnotes:1:ref11" class="refnotes-ref note-popup">[4]</a>. The idea is to pull one or more existing transitions into the core, upsetting its balance and thus eliminating it.
</p>

<p>
<img src="concurrency-reduction-simple.svg" width="295" height="144" class="svgscaleinsert mediacenter" alt="Core elimination by concurrency reduction.">
</p>

<p>
In the presence of choices, the CRs may be more complicated, as illustrated below <a href="#refnotes:1:note3" name="refnotes:1:ref12" class="refnotes-ref note-popup">[3]</a> <a href="#refnotes:1:note4" name="refnotes:1:ref13" class="refnotes-ref note-popup">[4]</a>. An extra place may be necessary in such a case to handle all the branches of the choice to avoid violating the consistency of the <abbr title="Signal Transition Graph">STG</abbr>. (This case is mentioned here for completeness, but we do not use such CRs in the rest of the tutorial.)
</p>

<p>
<img src="concurrency-reduction-choice.svg" width="328" height="178" class="svgscaleinsert mediacenter" alt="Core elimination by concurrency reduction in presence of a choice.">
</p>
<div class="wrap_hide plugin_wrap"><div class="wrap_center wrap_round wrap_info plugin_wrap" style="width: 90%;">
<p>
CRs can be used (along with signal insertions) for automatic resolution of CSC conflicts – for that you need to provide an extra command line parameter <code>-r</code> to MPSat via <em>Edit→Preferences…→MPSat verification→Additional parameters</em>. <span class="wrap_important ">The resulting automatic solution has to be carefully reviewed by the designer, as MPSat does not discriminate between innocuous and risky CRs, and aggressively uses those that are most likely to reduce the number of literals; e.g. for the VME bus controller example it picks the risky CR that fully sequentialises the behaviour and violates the high-level purpose of the design.</span>
</p>
</div></div>
<p>
Four alternative ways to use CR to resolve the encoding conflicts in the A2D example are shown below – only one (any) of the four amber arcs is added. The reason any of these CRs resolves all the conflicts is interesting:
</p>
<ul>
<li class="level1"><div class="li"> <code><span style='color:blue; '>ready+</span></code> and perhaps also <code><span style='color:red; '>start-</span></code> are pulled into the overlap of four cores (forming the highest peak) and destroy these four cores;</div>
</li>
<li class="level1"><div class="li"> at the same time,  <code><span style='color:blue; '>Lr-</span></code>, <code><span style='color:red; '>Laf-</span></code>, and perhaps <code><span style='color:blue; '>Ar-</span></code> are pulled into the remaining core destroying it too.</div>
</li>
</ul>

<p>
<img src="screenshot-a2d-core_and_height_map-cr.png" class="mediacenter" title="A2D controller: 4 different ways to resolve the CSC conflicts by concurrency reduction" alt="A2D controller: 4 different ways to resolve the CSC conflicts by concurrency reduction" />
</p>
<pre class="code">// innocuous CR: ready+ -&gt; Ar-; 14 literals
[Ar] = (Lam&#039; ready&#039; + Laf&#039; ready) (Ar + Ad&#039;); 
[Lr] = Ar (Ad ready&#039; start + Laf); 
[ready] = ready start + Laf; </pre>
<pre class="code">// innocuous CR: ready+ -&gt; Lr-; 14 literals
[Ar] = Laf&#039; Lam&#039; (Ar + Ad&#039;); 
[Lr] = ready&#039; (Ar Ad start + Laf) + Laf Ar; 
[ready] = ready start + Laf; </pre>
<div class="wrap_center wrap_round wrap_important plugin_wrap" style="width: 90%;"><pre class="code">// risky CR: start- -&gt; Ar-; 11 literals
[Ar] = (Laf&#039; start&#039; + Lam&#039; start) (Ar + Ad&#039;); 
[Lr] = Ar (start Ad + Laf); 
[ready] = Laf;</pre>
<pre class="code">// risky CR: start- -&gt; Lr-; 11 literals
[Ar] = Laf&#039; Lam&#039; (Ar + Ad&#039;); 
[Lr] = start (Ad Ar + Laf) + Laf Ar; 
[ready] = Laf; </pre>
</div>
<p>
The CRs <code><span style='color:blue; '>ready+</span></code> → <code><span style='color:blue; '>Ar-</span></code> and <code><span style='color:blue; '>ready+</span></code> → <code><span style='color:blue; '>Lr-</span></code> are innocuous, and the corresponding complex-gate implementations both have 14 literals – which happens to be the same as MPSat&#039;s automatic resolution by signal insertion.
</p>

<p>
The complex-gate implementations for the CRs <code><span style='color:red; '>start-</span></code> → <code><span style='color:blue; '>Ar-</span></code> and <code><span style='color:red; '>start-</span></code> → <code><span style='color:blue; '>Lr-</span></code> are much smaller (only 11 literals) and so advantageous from the area point of view. However, in contrast to the previous two CRs, these CRs are risky: they rely on the environment producing <code><span style='color:red; '>start-</span></code> soon after <code><span style='color:blue; '>ready+</span></code>, as otherwise many transitions get delayed. Hence these CRs have to be carefully considered by the human designer and agreed with the environment&#039;s designer. In this particular case, Alex Yakovlev (one of the designers of this A2D controller) explained that:
</p>
<ul>
<li class="level1"><div class="li"> <code><span style='color:red; '>start</span></code> / <code><span style='color:blue; '>ready</span></code> is an “external” handshake to the user of the A2D controller; a ubiquitous component like an A2D converter should not rely on the environment to send <code><span style='color:red; '>start-</span></code> fast;</div>
</li>
<li class="level1"><div class="li"> <code><span style='color:red; '>start-</span></code> may be controlled by a clock, and so be <em>very</em> slow;</div>
</li>
<li class="level1"><div class="li"> there are situations, however, when <code><span style='color:red; '>start-</span></code> is fast.</div>
</li>
</ul>

<p>
When choosing a concurrency reduction, one has to make sure that:
</p>
<ul>
<li class="level1"><div class="li"> no input is directly delayed by the new arc (this will definitely change the contract with the environment, expecting it to wait for some transitions before delivering this input);</div>
</li>
<li class="level1"><div class="li"> the added arc cannot accumulate unbounded number of tokens, i.e. the <abbr title="Signal Transition Graph">STG</abbr> remains bounded;</div>
</li>
<li class="level1"><div class="li"> the output persistency is not violated;</div>
</li>
<li class="level1"><div class="li"> no deadlocks have been introduced (e.g. if risky CRs are used both to simplify the circuit and, independently, the environment then all the added arcs may accidentally form a loop leading to a deadlock due to circular waiting);</div>
</li>
<li class="level1"><div class="li"> the concurrency reduction resolves some of the CSC conflicts.</div>
</li>
</ul>

<p>
(Note that the consistency cannot be violated by concurrency reduction, as it can only restrict the behaviour of the <abbr title="Signal Transition Graph">STG</abbr>, i.e. no new traces can be introduced.) One should also prefer innocuous CRs, and use the risky ones only if there is a <em>very</em> compelling reason to do so, and remember to vet these with the designer of the environment!
</p>

<p>
In addition to these, one should try to heuristically optimise the final implementation, using similar heuristics to those explained above for signal insertion. In particular, one should try not to introduce new signal triggers if at all possible.
</p>

<p>
Considerations when using concurrency reduction:
</p>
<ul>
<li class="level1"><div class="li"> no new signals to implement <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;</div>
</li>
<li class="level1"><div class="li"> reduced state graph and so more don&#039;t-cares in minimisation tables, which may result in a better implementation <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;</div>
</li>
<li class="level1"><div class="li"> risky CRs change the behaviour in significant ways, breaking the contract with the environment <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />;</div>
</li>
<li class="level1"><div class="li"> risky CRs can introduce deadlocks <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />;</div>
</li>
<li class="level1"><div class="li"> even when no deadlocks are introduced, risky CRs may drastically deteriorate the performance due to sequentialisation without the designer realising this (cf. the latter concurrency reduction in VME bus controller example above) <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />.</div>
</li>
</ul>
<div class="wrap_center wrap_round wrap_tip plugin_wrap" style="width: 90%;">
<p>
CRs can be used for simplifying the logic, even when there are no encoding conflicts. E.g. if several concurrent outputs are triggered by the same transition and have no other triggers, one can try various possible innocuous CRs between them to simplify the logic. E.g. in the VME bus controller <abbr title="Signal Transition Graph">STG</abbr> above, after the conflicts have been resolved by inserting a new signal <code><span style='color:green; '>csc</span></code>, <code><span style='color:blue; '>d-</span></code> is the only trigger of concurrent output transitions <code><span style='color:blue; '>dtack-</span></code> and <code><span style='color:blue; '>lds-</span></code>, so one can try innocuous CRs <code><span style='color:blue; '>dtack-</span></code> → <code><span style='color:blue; '>lds-</span></code> and <code><span style='color:blue; '>lds-</span></code>→<code><span style='color:blue; '>dtack-</span></code> and see if any of them improves the circuit.
</p>
</div>
</div>

<h4 id="exercise_3">Exercise 3</h4>
<div class="level4">

<p>
For the <abbr title="Signal Transition Graph">STG</abbr> in <a href="start.html#exercise_1" class="wikilink1" title="tutorial:method:csc_resolution:start" data-wiki-id="tutorial:method:csc_resolution:start">Exercise 1</a> above:
</p>
<ul>
<li class="level1 node"><div class="li"> Manually resolve the encoding conflicts by concurrency reduction:</div>
<ul>
<li class="level2"><div class="li"> Think which events can be pulled into the cores to break the balance.</div>
</li>
<li class="level2"><div class="li"> Use only innocuous CRs, as this tutorial does not provide sufficient information about the environment of this <abbr title="Signal Transition Graph">STG</abbr> to vet risky CRs.</div>
</li>
<li class="level2"><div class="li"> Try to reduce the number of signal triggers – this is likely to result in a smaller complex-gate implementation.</div>
</li>
<li class="level2"><div class="li"> Do not forget to highlight the CRs by making the corresponding arcs amber and thick (with bigger arrowheads) by editing the properties of the corresponding arcs in the <em>Property editor</em>.</div>
</li>
<li class="level2"><div class="li"> Do not forget to verify the modified <abbr title="Signal Transition Graph">STG</abbr> as explained in <a href="start.html#exercise_2" class="wikilink1" title="tutorial:method:csc_resolution:start" data-wiki-id="tutorial:method:csc_resolution:start">Exercise 2</a>.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Once all the encoding conflicts are resolved, synthesise the complex-gate implementation and compare the number of literals with that in the solutions to previous exercises.</div>
</li>
<li class="level1"><div class="li"> Even after the encoding conflicts are resolved, use more innocuous CRs to improve the number of literals in the complex-gate implementation. You should be able to get a solution with 23 literals without much effort. The number of literals can be found towards the end in the <em>Output</em> pane after the complex-gate synthesis has been performed.</div>
</li>
</ul>

</div>

<h3 id="transition_reordering">Transition reordering</h3>
<div class="level3">

<p>
Severity level: <span style='color:orange; '>Antibiotic</span>
</p>

<p>
Consider the following <abbr title="Signal Transition Graph">STG</abbr>, where the intention is to execute the <code><span style='color:blue; '>r</span> / <span style='color:red; '>a</span></code> handshake on the output port in response to a handshake on one of the input ports (either <code><span style='color:red; '>r1</span> / <span style='color:blue; '>a1</span></code> or <code><span style='color:red; '>r2</span> / <span style='color:blue; '>a2</span></code>). The input handshakes are assumed to be mutually exclusive, and a new input request (either <code><span style='color:red; '>r1+</span></code> or <code><span style='color:red; '>r2+</span></code>) is allowed to arrive while the output handshake is still in progress. 
</p>

<p>
<img src="call-original.stg.svg" width="439" height="124" class="svgscaleinsert mediacenter" alt="Original specification with non-overlapping handshakes">
</p>

<p>
This <abbr title="Signal Transition Graph">STG</abbr> has a CSC conflict between the initial state and the state reached when either input handshake is complete. Since there is very little concurrency, concurrency reduction cannot be used to resolve this conflict. It is possible to resolve the conflict using signal insertion in the normal way, but this will lead to area and latency overheads due to the necessity to implement the inserted signal, as explained above.
</p>

<p>
Often there is some flexibility in the order of signals, in particular if four-phase handshakes are involved: Usually only the rising edges of request and acknowledgement are used for communicating, and the falling edges are not meaningful (other than returning the signals back to zero). If this is the case, there is some flexibility in positioning the corresponding transitions in the <abbr title="Signal Transition Graph">STG</abbr>, and this flexibility can be exploited for resolving CSC conflicts and/or improving the quality of the circuit in terms of area and latency.
</p>

<p>
Consider the alternative specification where the falling edges of the input handshakes are concurrent to the rising edges of the output handshake, i.e. the input and output handshakes now overlap in time:
</p>

<p>
<img src="call-final.stg.svg" width="439" height="150" class="svgscaleinsert mediacenter" alt="Specification after signal reordering, with overlapping handshakes">
</p>

<p>
Of course, this transformation changes the contract with the environment, and so one has to be carefull when introducing it, in particular this should be agreed with the designer of the environment. However, if it is indeed possible to use this <abbr title="Signal Transition Graph">STG</abbr>, it has several advantages:
</p>
<ul>
<li class="level1"><div class="li"> The active phase of the output handshake no longer has to wait for an input handshake to complete (removing <code><span style='color:blue; '>r1-</span> –&gt; <span style='color:red; '>a1-</span></code> or <code><span style='color:blue; '>r2-</span> –&gt; <span style='color:red; '>a2-</span></code> from the critical path), which may significantly reduce the latency of the circuit;</div>
</li>
<li class="level1"><div class="li"> There are no CSC conflicts any more, hence no need to insert and implement any new signals;</div>
</li>
<li class="level1"><div class="li"> Now the input and output handshakes are partially ‘locked’ with each other (as explained above, locking is a good heuristic for simplifying the resulting circuit).</div>
</li>
</ul>

<p>
Indeed, the circuit synthesised from this <abbr title="Signal Transition Graph">STG</abbr> is rather simple and natural:
</p>

<p>
<img src="call-final.circuit.svg" width="161" height="78" class="svgscaleinsert mediacenter" alt="Circuit corresponding to the STG with reordered signals">
</p>

<p>
Conceptually, such designs can be obtained using the methodology similar to the one described in <a href="#refnotes:1:note6" name="refnotes:1:ref14" class="refnotes-ref note-popup">[6]</a>. As an example of its use, consider the <abbr title="Signal Transition Graph">STG</abbr> below, that is equivalent to the above design after transition reordering. First, the transitions of the falling edges of signals in each four-phase handshake can be made concurrent to every transition of every signal exept those participating in this handshake; that is, handshakes are represented by disjoint four transitions cycles – there are three such cycles in the <abbr title="Signal Transition Graph">STG</abbr> below. This <abbr title="Signal Transition Graph">STG</abbr> expresses the maximal possible behaviour obeying the hanshake protocol – all the ports concurrently and independently execute handshakes. Then the required protocol and interactions between input and output ports are modelled by introducing some places and arcs in this <abbr title="Signal Transition Graph">STG</abbr> (thus restricting its behaviour). In this particular case, a new place expressing a choice between <code><span style='color:red; '>r1+</span></code> or <code><span style='color:red; '>r2+</span></code> is added and appropriately connected to the transitions of the input handshakes so that to make them mutually exclusive. Furthermore, two places are added and appropriately connected to express the triggering relation between either <code><span style='color:blue; '>a1+</span></code> or <code><span style='color:blue; '>a2+</span></code> and <code><span style='color:blue; '>r+</span></code>, and between <code><span style='color:red; '>a-</span></code> and either <code><span style='color:blue; '>a1+</span></code> or <code><span style='color:blue; '>a2+</span></code>. Then concurrency reduction for the falling edges is used for optimisation purposes – there are multiple possibilities, and the one shown by amber places and arcs results in an <abbr title="Signal Transition Graph">STG</abbr> equivalent to the above design.
</p>

<p>
<img src="call-handshakes.stg.svg" width="207" height="168" class="svgscaleinsert mediacenter" alt="Specification after signal reordering, with overlapping handshakes">
</p>

<p>
Considerations when using transition reordering:
</p>
<ul>
<li class="level1"><div class="li"> no new signals to implement <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;</div>
</li>
<li class="level1"><div class="li"> potential improvements in the latency due to removing falling edges from the critical path <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;</div>
</li>
<li class="level1"><div class="li"> potential improvements in the quality of the circuit due to more locking between signals, which is a good heuristic for reducing the logic complexity <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;</div>
</li>
<li class="level1"><div class="li"> the behaviour may change in significant ways, breaking the contract with the environment <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />;</div>
</li>
<li class="level1"><div class="li"> need to re-design the <abbr title="Signal Transition Graph">STG</abbr>, often manually <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" /> (this can be alleviated to some degree, e.g. <a href="../../../help/backend/petrify.html" class="wikilink1" title="help:backend:petrify" data-wiki-id="help:backend:petrify">Petrify backend</a> allows the user to declare some signals as having ‘free return to zero’, and the tool then automatically inserts the falling transitions with the view to obtain a consistent <abbr title="Signal Transition Graph">STG</abbr> with a (heuristically) good implementation; unfortunately this functionality is not available from Workcraft front-end yet);</div>
</li>
</ul>

</div>

<h4 id="exercise_4">Exercise 4</h4>
<div class="level4">

<p>
Download the following <abbr title="Signal Transition Graph">STG</abbr>, which is a 2-way paralleliser similar to the one considered <a href="start.html#visualisation_of_csc_conflicts_at_the_level_of_state_graphs" class="wikilink1" title="tutorial:method:csc_resolution:start" data-wiki-id="tutorial:method:csc_resolution:start">above</a>: <span class="wrap_download "><a href="par2.work" class="media mediafile mf_work" title="tutorial:method:csc_resolution:par2.work (3.3 KB)">2-way paralleliser.</a> (3 KiB)</span>:
</p>

<p>
<img src="par2.svg" width="124" height="244" class="svgscaleinsert mediacenter" alt="STG specification of 2-way paralleliser">
</p>

<p>
Assuming that only the positive signal edges are meaningful, resolve the CSC conflicts in this <abbr title="Signal Transition Graph">STG</abbr> using transition reordering. Synthesise the mapped implementation of this <abbr title="Signal Transition Graph">STG</abbr>. It is possible to design this circuit using just a C-element and a couple of buffers (implemented as wires); if your implementation is more complicated then try an alternative reordering of transitions.
</p>

</div>

<h3 id="making_extra_inputs_available">Making extra inputs available</h3>
<div class="level3">

<p>
Severity level: <span style='color:orange; '>Antibiotic</span>
</p>

<p>
It can happen that including extra input signals from the environment, which are not strictly necessary for implementing the <abbr title="Signal Transition Graph">STG</abbr>, helps to resolve encoding conflicts. This requires restructuring the <abbr title="Signal Transition Graph">STG</abbr> in major ways. This technique is currently underexplored, in particular there are no clear guidelines on how to choose the signals that need to be included, other than appealing to the designer&#039;s “understanding of the system” and “creativity”. For small systems one can try to include all (or as many as possible) signals from the environment and see whether the complex-gate implementations becomes simpler and which of the newly included signals occur in the equations. In particular, if the environment (or a part thereof) is specified by STGs, one can compose all or some of them with the <abbr title="Signal Transition Graph">STG</abbr> specifying the circuit (<em>Tools→Composition→Parallel composition [PComp]</em> menu item) and try to synthesise the composed <abbr title="Signal Transition Graph">STG</abbr>: it may happen that the implementations of some of the signals become simpler, and one can find useful signals by examining the equations. Note however that the composed <abbr title="Signal Transition Graph">STG</abbr> may be large and difficult to synthesise.
</p>

<p>
Consider the following <abbr title="Signal Transition Graph">STG</abbr> specifying a part of an SRAM controller <a href="#refnotes:1:note1" name="refnotes:1:ref15" class="refnotes-ref note-popup">[1]</a>.
</p>

<p>
<img src="screenshot-flip_slave-coremap.png" class="mediacenter" title="A part of an SRAM controller (FlipSlave): core map" alt="A part of an SRAM controller (FlipSlave): core map" />
</p>

<p>
Automatic resolution inserts two new internal signals and yields the following complex-gate implementation with 18 literals:
</p>
<pre class="code">[WE] = B0&#039; csc1&#039; + B1&#039; csc0&#039;; 
[done] = B0 csc1&#039; + B1 csc0&#039; + WE flip&#039;; 
[csc0] = B0&#039; csc0 + csc1&#039; + flip&#039;; 
[csc1] = B1&#039; csc1 + csc0&#039; + flip&#039;; </pre>

<p>
Alternatively, one can resolve some of the conflicts using innocuous CRs as shown below:
</p>

<p>
<img src="screenshot-flip_slave_intermediate-coremap.png" class="mediacenter" title="A part of an SRAM controller (FlipSlave) with some encoding conflicts resolved by innocuous CRs: core map" alt="A part of an SRAM controller (FlipSlave) with some encoding conflicts resolved by innocuous CRs: core map" />
</p>

<p>
The above <abbr title="Signal Transition Graph">STG</abbr> still has some encoding conflicts, but they can be resolved by inserting a single signal, yielding the following complex-gate implementation with 18 literals:
</p>
<pre class="code">[WE] = done&#039; (B1&#039; flip + csc0&#039; + WE); 
[done] = WE (B1 csc0 + done) + B0 csc0&#039; + flip done; 
[csc0] = csc0 (WE + B0) + done + flip&#039;; </pre>

<p>
However, by vigorously applying “understanding of the system” and “creativity”, the designers of this SRAM controller observed that two signals in the environment, <code><span style='color:red; '>D0</span></code> and <code><span style='color:red; '>D1</span></code>, can help the implementation to trace its current state and get rid of the encoding conflicts (in fact, any of these signals would have been sufficient, but it is better to include them both for the reasons explained below). The <abbr title="Signal Transition Graph">STG</abbr> had to be manually restructured to include these two signals:
</p>

<p>
<img src="flip_slave_no_cr.svg" width="501" height="562" class="svgscaleinsert mediacenter" alt="A part of an SRAM controller (FlipSlave) with extra input signals added to resolve the encoding conflicts">
</p>

<p>
This <abbr title="Signal Transition Graph">STG</abbr> is free from encoding conflicts, and yields the following implementation with 11 literals:
</p>
<pre class="code">[WE] = flip (D0&#039; B1&#039; + B0&#039; D0); 
[done] = (WE + flip) (D0 + B1) (B0 + D0&#039;); </pre>

<p>
Furthermore, one can simplify this implementation by applying two innocuous CRs as shown below. Note that these CRs are used not for conflict resolution, but for simplifying the implementation to help with subsequent technology mapping.
</p>

<p>
<img src="flip_slave_final.svg" width="501" height="562" class="svgscaleinsert mediacenter" alt="Using CRs to simplify the complex-gate implementation">
</p>

<p>
The resulting complex-gate implementation has only 8 literals:
</p>
<pre class="code">[WE] = done&#039; flip; 
[done] = (WE + flip) (D0 + B1) (B0 + D0&#039;); </pre>

<p>
Note that <code><span style='color:red; '>D1</span></code> is not used in this implementation. However, one can deploy it instead of <code><span style='color:red; '>D0&#039;</span></code>, getting rid of the inversion that is likely to be finally mapped to an inverter with a timing assumption on its delay:
</p>
<pre class="code">[WE] = done&#039; flip; 
[done] = (WE + flip) (D0 + B1) (B0 + D1); </pre>

<p>
Note that this manual modification of the circuit must be formally verified against the <abbr title="Signal Transition Graph">STG</abbr> using <em>Verification→Conformation, deadlock freeness, and output persistency (reuse unfolding) [MPSat]</em> menu item.
</p>

<p>
Considerations when adding extra inputs:
</p>
<ul>
<li class="level1"><div class="li"> no new signals to implement – the extra signals are already implemented in the environment  <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;</div>
</li>
<li class="level1"><div class="li"> not clear how to choose the new inputs <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />;</div>
</li>
<li class="level1"><div class="li"> need to re-design the <abbr title="Signal Transition Graph">STG</abbr>, often manually, changing the contract with the environment <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />.</div>
</li>
</ul>

</div>

<h3 id="relative_timing_assumptions">Relative timing assumptions</h3>
<div class="level3">

<p>
Severity level: <img src="surgery.png" class="media" alt="" />
</p>
<div class="wrap_center wrap_round wrap_alert plugin_wrap" style="width: 90%;">
<p>
Timing assumptions offer the designer unlimited opportunities to shoot oneself in a foot.
</p>
</div>
<p>
Intuitively, <em>Relative Timing Assumptions (RTAs)</em> state, “This transition will fire faster than that one” (see Chapter 7 of <a href="#refnotes:1:note7" name="refnotes:1:ref16" class="refnotes-ref note-popup">[7]</a> – much of the material below comes from there). The difference from <em>Absolute Timing Assumptions (ATAs)</em> is that no specific delays (or intervals thereof) of events are assumed – just assumptions about the order of firing of concurrent transitions are made.
</p>

<p>
As an example, consider the VME bus controller <abbr title="Signal Transition Graph">STG</abbr>. If the environment is known to be slow and <code><span style='color:red; '>dsr+</span></code> will definitely arrive after <code><span style='color:blue; '>lds-</span></code> fires (or this can be enforced by transistor sizing, etc.), one can synthesise the circuit with this assumption taken into account. In the picture below this RTA is illustrated by a red arc.
</p>

<p>
<img src="stg-vme-read-rta.svg" width="406" height="102" class="svgscaleinsert mediacenter" alt="VME bus controller: resolving the CSC conflict using a relative timing assumption">
</p>
<div class="wrap_center wrap_round wrap_tip plugin_wrap" style="width: 90%;">
<p>
In contrast to concurrency reduction arcs, which are just regular <abbr title="Signal Transition Graph">STG</abbr> arcs, RTA arcs have very different semantics. In particular, they do not add any triggers to their target transitions. Moreover, an arc&#039;s target can be a transition of an input signal, which was not possible for concurrency reductions.
</p>
</div>
<p>
The conventional state graphs can no longer adequately express the semantics of STGs with RTAs, and an extended formalism, called <em>lazy transition systems,</em> is explained in <a href="#refnotes:1:note7" name="refnotes:1:ref17" class="refnotes-ref note-popup">[7]</a>. The lazy transition system for the above <abbr title="Signal Transition Graph">STG</abbr> is as follows. Note that due to the RTA one of the states involved in the CSC conflict has become unreachable, and the conflict has disappeared. The difference from the traditional state graphs is that the <em>firing region</em> of a signal can be a proper subset of its <em>enabling region,</em> i.e. there may be states where a signal is enabled but cannot fire due to timing. (In traditional state graphs the enabling and firing regions are always the same, and so there is no need to distinguish between them.) For example, <code><span style='color:red; '>dsr+</span></code> is enabled in states <code>s0_00000</code>, <code>s9_01000</code>, and <code>s11_01001</code>, but can only fire in the former two states due to the RTA. The dashed arc originating in <code>s11_01001</code> is called <em>lazy</em> and can never be taken (but it cannot be dropped, as it prevents <code><span style='color:blue; '>lds-</span></code> becoming a trigger of <code><span style='color:red; '>dsr+</span></code>, which would change the semantics). Lazy arcs do not have target states (and do not need them as they are never taken); in this example state <code>s2_11001_csc</code> is unreachable and so is not even a part of the lazy transition system.
</p>

<p>
<img src="vme-read-sg-rta.svg" width="557" height="445" class="svgscaleinsert mediacenter" alt="VME bus controller: The lazy transition system corresponding to the above STG with an RTA">
</p>

<p>
<strong>Examples of common RTAs:</strong>
</p>
<ul>
<li class="level1"><div class="li"> Detaching an input ‘bubble’ of a gate as an actual inverter. This is usually ok, provided that the maximum delay of an inverter is smaller than the minimum delay of any other gate and this inverter is placed next to the gate (avoiding thus a wire delay). Note that this imposes constraints on placing and routing. Unfortunately, the logic synthesis and technology mapping procedures often introduce such inverters with RTAs (there are good technical reasons for that). <span class="wrap_tip ">Note that in contrast to input bubbles, detaching an output ‘bubble’ does not break speed-independence and thus does not require any RTAs.</span></div>
</li>
<li class="level1 node"><div class="li"> “I know that my environment is slow” – this is often the case (with appropriate constraints on placing and routing), but one must be careful:</div>
<ul>
<li class="level2"><div class="li"> the environment is often just another part of the circuit, and can be very fast;</div>
</li>
<li class="level2"><div class="li"> the environment may be changed without your knowledge by the designer next-door (as explained above for concurrency reductions, but the effects become much more subtle now);</div>
</li>
<li class="level2"><div class="li"> the delays in the environment may be significantly affected by all sorts of variations, like voltage, temperature, etc.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> “Three gates are always slower than one in my technology library”. This is usually ok, but one has to be careful with wire delays, and impose appropriate constraints on placing and routing.</div>
</li>
</ul>

<p>
The rational for preferring RTAs over ATAs is that the precise timing is not known at this stage:
</p>
<ul>
<li class="level1"><div class="li"> <abbr title="Signal Transition Graph">STG</abbr> specifications are often incomplete, e.g. internal signals need to be inserted to resolve CSC conflicts or break up large complex-gates to map them to the gates available in the given library.</div>
</li>
<li class="level1"><div class="li"> Even after adding such signals, the precise absolute timing information is not available until technology mapping is complete. This leads to a chicken-and-egg problem: for efficiency, synthesis needs delay bounds, but delay bounds are unknown until synthesis is completed. In timed synthesis this problem is solved by iterating delay guessing and synthesis without guarantee of convergence.</div>
</li>
<li class="level1"><div class="li"> Synthesis flows usually include transistor or gate sizing, buffer insertion and selection of various parameters like threshold voltage. A netlist can be sized differently depending on a given set of constraints, and the resulting delays may differ by an order of magnitude depending on the selected sizes and parameters.</div>
</li>
<li class="level1"><div class="li"> Placement and routing may further change delays.</div>
</li>
</ul>

<p>
Note that much of the above applies not just to ATAs but to RTAs too; however, RTAs are generally much easier to satisfy after logic synthesis than ATAs. RTAs are also less fragile than ATAs as gates&#039; delays often respond to some kinds of variation (e.g. temperature or voltage) in a similar way.  
</p>

<p>
The synthesis flow with RTAs follows the paradigm, <em>assume and, if useful, guarantee</em>:
</p>
<ol>
<li class="level1"><div class="li"> Heuristically guess a set of RTAs.</div>
</li>
<li class="level1"><div class="li"> Synthesise the circuit under these RTAs.</div>
</li>
<li class="level1"><div class="li"> Derive a subset of RTAs sufficient to guarantee the correctness of this circuit (some of the original RTAs may happen to be redundant for this particular circuit).</div>
</li>
<li class="level1"><div class="li"> Perform transistor sizing and parameter selection to satisfy this subset of constraints.</div>
</li>
<li class="level1"><div class="li"> If the latter is impossible, select a less stringent set of RTAs and try again.</div>
</li>
</ol>
<div class="wrap_center wrap_round wrap_important plugin_wrap" style="width: 90%;">
<p>
Though RTAs are less fragile than ATAs, they do break the speed-independence of the circuit. This introduces a number of problems, in particular:
</p>
<ul>
<li class="level1"><div class="li"> It is VERY easy to make a mistake. Such mistakes are often almost impossible to catch during simulation, as they would happen only in a narrow range of delays of inputs and other parameters like temperature, voltage, etc.</div>
</li>
<li class="level1"><div class="li"> Even if the circuit is correct, it is much less robust to all sorts of variations, like temperature, manufacturing, voltage, etc.</div>
</li>
<li class="level1"><div class="li"> RTAs are fragile and have to be re-checked every time even a minor modification is applied to the circuit.</div>
</li>
<li class="level1"><div class="li"> Most of the synthesis and verification flow for the speed-independent circuits implemented in Workcraft will not work for circuits with RTAs.</div>
</li>
</ul>
</div><div class="wrap_center wrap_round wrap_tip plugin_wrap" style="width: 90%;">
<p>
RTAs are supported by the Petrify back-end, and one can use them by exporting an <abbr title="Signal Transition Graph">STG</abbr> from Workcraft via <em>File→Export→.g (Workcraft <abbr title="Signal Transition Graph">STG</abbr> serialiser)</em> and then manually adding RTAs to the exported <code>.g</code> file and executing Petrify from the command line. (Petrify can automatically suggest RTAs – for this example it suggests the same RTA as the one shown in the picture.)
</p>

<p>
For example, the following <code>.g</code> file was obtained by exporting the VME bus controller <abbr title="Signal Transition Graph">STG</abbr> and manually adding the RTA (the line <code>.time lds-&lt;|dsr+</code> towards the end):
</p>
<pre class="code"># STG file generated by Workcraft -- http://workcraft.org/
.model Untitled
.inputs dsr ldtack
.outputs d dtack lds
.graph
d+ dtack+
d- dtack- lds-
dsr+ lds+
dsr- d-
dtack+ dsr-
dtack- dsr+
lds+ ldtack+
lds- ldtack-
ldtack+ d+
ldtack- lds+

.time lds-&lt;|dsr+

.marking {&lt;dtack-,dsr+&gt; &lt;ldtack-,lds+&gt;}
.end</pre>

<p>
By feeding this file to Petrify, the following complex-gate implementation with 8 literals can be obtained:
</p>
<pre class="code">[d] = dsr lds ldtack; 
[dtack] = d; 
[lds] = dsr (ldtack&#039; + lds) + d; </pre>

<p>
Note that the complex-gate implementation obtained above by signal insertion also had 8 literals, without any of the troubles and risks associated with RTAs. In general, however, RTAs can deliver some improvements in terms of area and/or performance, and the more aggressive these RTAs are, the bigger improvements are likely to be achieved, and the bigger are the associated troubles and risks.
</p>
</div>
<p>
Considerations when using timing assumptions:
</p>
<ul>
<li class="level1"><div class="li"> no new signals to implement <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;</div>
</li>
<li class="level1"><div class="li"> reduced state graph and so more don&#039;t-cares in minimisation tables, which may result in a better implementation <img src="../../lib/images/smileys/icon_smile.gif" class="icon" alt=":-)" />;</div>
</li>
<li class="level1"><div class="li"> require deep understanding of theory and the circuit&#039;s behaviour – it is VERY easy to make a mistake, and such mistakes can be very difficult to catch by simulation as they will occur only in some corner cases <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />;</div>
</li>
<li class="level1 node"><div class="li"> break speed-independence of the circuit, so </div>
<ul>
<li class="level2"><div class="li"> cannot be verified using the standard speed-independent design flow and tools <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />;</div>
</li>
<li class="level2"><div class="li"> inherently fragile due to variability (manufacturing, temperature, voltage, etc.) <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />;</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> introduce place &amp; route constraints, and need extensive validation <img src="../../lib/images/smileys/icon_sad.gif" class="icon" alt=":-(" />.</div>
</li>
</ul>

</div>

<h2 id="solutions">Solutions</h2>
<div class="level2">

<p>
The Workcraft models discussed in this tutorial can be downloaded here: <span class="wrap_download "><a href="csc-resolution.zip" class="media mediafile mf_zip" title="tutorial:method:csc_resolution:csc-resolution.zip (240.7 KB)">CSC resolution models</a> (241 KiB)</span>
</p>

</div>
<div class="level1">
<div class="plugin_include_content plugin_include__tutorial:feedback" id="plugin_include__tutorial__feedback">
<div class="wrap_hide plugin_wrap"><pre class="code">===== Feedback =====</pre>
<form class="bureaucracy__plugin" id="bureaucracy__plugin1" enctype="multipart/form-data" method="post" action="start.html" accept-charset="utf-8"><div class="no">
<input type="hidden" name="sectok" value="76e97b919f59bf5330d969a72ba5bf17" /><input type="hidden" name="id" value="tutorial:method:csc_resolution:start" /><input type="hidden" name="bureaucracy[$$id]" value="1" /><fieldset ><legend>Comments or suggestions for improving this tutorial</legend>
<label><span>Name (optional)</span> <input type="text" name="bureaucracy[1]" class="edit" /></label>
<label><span>Email (optional)</span> <input type="text" name="bureaucracy[2]" class="edit" /></label>
<label class=" textareafield">
    <span>Feedback <sup>*</sup></span>
    <textarea name="bureaucracy[3]" id="" rows="10" cols="10" class="edit required&quot; required=&quot;required"></textarea>
</label><button type="submit">Submit</button>
</fieldset>
</div></form>
</div><div class="wrap_hide plugin_wrap"><ul>
<li class="level1"><div class="li"> As discussed in <a href="https://www.dokuwiki.org/plugin:include#controlling_header_size_in_included_pages" class="urlextern" title="https://www.dokuwiki.org/plugin:include#controlling_header_size_in_included_pages" rel="ugc nofollow">https://www.dokuwiki.org/plugin:include#controlling_header_size_in_included_pages</a>, by default, the headers in included pages start one level lower than the last header in the current page. This can be tweaked by adding an empty header above the include:\\<pre class="code">====== ======
{{page&gt;:tutorial:feedback&amp;inline}}</pre>
</div>
</li>
<li class="level1"><div class="li"> For offline help generation the content of <code>feedback</code> page should be temporary wrapped in <code>&lt;WRAP hide&gt;</code>. Note that the headers still propagate to the table of contents even if inside the hidden wrap. Therefore the <strong>Feedback</strong> title needs to be converted to something else, e.g. to code by adding two spaces in front.</div>
</li>
</ul>
</div></div>
















<div class="wrap_hide plugin_wrap">

</div>
</div>
<div class="refnotes">
<hr>
<div class="notes">
<div class="note left">
<b><a name="refnotes:1:note1" class="nolink">[1]</a></b>
<span id="refnotes:1:note1:text">
V. Khomenko, A. Mokhov, D. Sokolov, A. Yakovlev: Formal Design and Verification of an Asynchronous SRAM Controller, Proc. ACSD (2017).
</span></div>
<div class="note left">
<b><a name="refnotes:1:note2" class="nolink">[2]</a></b>
<span id="refnotes:1:note2:text">
A. Madalinski, A. Bystrov, V. Khomenko, and A. Yakovlev: <a href="http://dx.doi.org/10.1049/ip-cdt:20030831" class="urlextern" title="http://dx.doi.org/10.1049/ip-cdt:20030831" rel="ugc nofollow">Visualization and Resolution of Coding Conflicts in Asynchronous Circuit Design</a>. Special Issue on Best Papers from DATE&#039;03, IEE Proceedings: Computers &amp; Digital Techniques 150(5) (2003) 285-293.
</span></div>
<div class="note left">
<b><a name="refnotes:1:note3" class="nolink">[3]</a></b>
<span id="refnotes:1:note3:text">
V. Khomenko, A. Madalinski and A. Yakovlev: <a href="http://dl.acm.org/citation.cfm?id=2366080" class="urlextern" title="http://dl.acm.org/citation.cfm?id=2366080" rel="ugc nofollow">Resolution of Encoding Conflicts by Signal Insertion and Concurrency Reduction Based on STG Unfoldings</a>. Special Issue on Best Papers from ACSD&#039;06, IOS Press, Fundamenta Informaticae 86(3) (2008) 299-323.
</span></div>
<div class="note left">
<b><a name="refnotes:1:note4" class="nolink">[4]</a></b>
<span id="refnotes:1:note4:text">
V. Khomenko: <a href="http://dx.doi.org/10.1109/TVLSI.2008.2012156" class="urlextern" title="http://dx.doi.org/10.1109/TVLSI.2008.2012156" rel="ugc nofollow">Efficient Automatic Resolution of Encoding Conflicts Using STG Unfoldings</a>. Special Section on Asynchronous Circuits and Systems, Joint Publication of IEEE Circuits and Systems Society, IEEE Computer Society and IEEE Solid-State Circuits Society, IEEE Transactions on Very Large Scale Integration (VLSI) Systems 17(7) (2009) 855-868. Also available <a href="http://homepages.cs.ncl.ac.uk/victor.khomenko/papers/ieee-tvlsi-csc.pdf" class="urlextern" title="http://homepages.cs.ncl.ac.uk/victor.khomenko/papers/ieee-tvlsi-csc.pdf" rel="ugc nofollow">here</a>.
</span></div>
<div class="note left">
<b><a name="refnotes:1:note5" class="nolink">[5]</a></b>
<span id="refnotes:1:note5:text">
D.J. Kinniment, B. Gao, A. Yakovlev, and F. Xia: <a href="http://dx.doi.org/10.1109/ASYNC.1998.666506" class="urlextern" title="http://dx.doi.org/10.1109/ASYNC.1998.666506" rel="ugc nofollow">Towards Asynchronous A-D Conversion</a>. Proc. ASYNC (1998) 206–215.
</span></div>
<div class="note left">
<b><a name="refnotes:1:note6" class="nolink">[6]</a></b>
<span id="refnotes:1:note6:text">
J. Cortadella, M. Kishinevsky, A. Kondratyev, L. Lavagno, and A. Yakovlev: Automatic Handshake Expansion and Reshuffling Using Con-currency Reduction, Proc. HWPN (1998).
</span></div>
<div class="note left">
<b><a name="refnotes:1:note7" class="nolink">[7]</a></b>
<span id="refnotes:1:note7:text">
J. Cortadella, M. Kishinevsky, A. Kondratyev, L. Lavagno, and A. Yakovlev: <a href="http://doi.org/10.1007/978-3-642-55989-1" class="urlextern" title="http://doi.org/10.1007/978-3-642-55989-1" rel="ugc nofollow">Logic Synthesis for Asynchronous Controllers and Interfaces</a>. Springer Series in Advanced Microelectronics, Vol. 8, 2002.
</span></div>
</div>
</div>

                    <!-- wikipage stop -->
                                    </div>
<!--
                <div class="docInfo">
                    workcraft @ <bdi>tutorial/method/csc_resolution/start.txt</bdi> · Modified 2020/06/07 16:37 by <bdi>victor</bdi>                </div>
-->
                            </div></div><!-- /content -->

            <hr class="a11y" />

            <!-- PAGE ACTIONS -->
<!--
            <div id="dokuwiki__pagetools">
                            <h3 class="a11y">Page Tools</h3>
                <div class="tools">
                    <ul>
                        <li class="edit"><a href="start.html" title="Edit this page [e]" rel="nofollow" accesskey="e"><span>Edit this page</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg></a></li><li class="revs"><a href="start.html" title="Old revisions [o]" rel="nofollow" accesskey="o"><span>Old revisions</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M11 7v5.11l4.71 2.79.79-1.28-4-2.37V7m0-5C8.97 2 5.91 3.92 4.27 6.77L2 4.5V11h6.5L5.75 8.25C6.96 5.73 9.5 4 12.5 4a7.5 7.5 0 0 1 7.5 7.5 7.5 7.5 0 0 1-7.5 7.5c-3.27 0-6.03-2.09-7.06-5h-2.1c1.1 4.03 4.77 7 9.16 7 5.24 0 9.5-4.25 9.5-9.5A9.5 9.5 0 0 0 12.5 2z"/></svg></a></li><li class="backlink"><a href="start.html" title="Backlinks" rel="nofollow"><span>Backlinks</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M10.59 13.41c.41.39.41 1.03 0 1.42-.39.39-1.03.39-1.42 0a5.003 5.003 0 0 1 0-7.07l3.54-3.54a5.003 5.003 0 0 1 7.07 0 5.003 5.003 0 0 1 0 7.07l-1.49 1.49c.01-.82-.12-1.64-.4-2.42l.47-.48a2.982 2.982 0 0 0 0-4.24 2.982 2.982 0 0 0-4.24 0l-3.53 3.53a2.982 2.982 0 0 0 0 4.24m2.82-4.24c.39-.39 1.03-.39 1.42 0a5.003 5.003 0 0 1 0 7.07l-3.54 3.54a5.003 5.003 0 0 1-7.07 0 5.003 5.003 0 0 1 0-7.07l1.49-1.49c-.01.82.12 1.64.4 2.43l-.47.47a2.982 2.982 0 0 0 0 4.24 2.982 2.982 0 0 0 4.24 0l3.53-3.53a2.982 2.982 0 0 0 0-4.24.973.973 0 0 1 0-1.42z"/></svg></a></li><li class="export_pdf"><a href="start.html" title="Export to PDF" rel="nofollow"><span>Export to PDF</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M14 9h5.5L14 3.5V9M7 2h8l6 6v12a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2m4.93 10.44c.41.9.93 1.64 1.53 2.15l.41.32c-.87.16-2.07.44-3.34.93l-.11.04.5-1.04c.45-.87.78-1.66 1.01-2.4m6.48 3.81c.18-.18.27-.41.28-.66.03-.2-.02-.39-.12-.55-.29-.47-1.04-.69-2.28-.69l-1.29.07-.87-.58c-.63-.52-1.2-1.43-1.6-2.56l.04-.14c.33-1.33.64-2.94-.02-3.6a.853.853 0 0 0-.61-.24h-.24c-.37 0-.7.39-.79.77-.37 1.33-.15 2.06.22 3.27v.01c-.25.88-.57 1.9-1.08 2.93l-.96 1.8-.89.49c-1.2.75-1.77 1.59-1.88 2.12-.04.19-.02.36.05.54l.03.05.48.31.44.11c.81 0 1.73-.95 2.97-3.07l.18-.07c1.03-.33 2.31-.56 4.03-.75 1.03.51 2.24.74 3 .74.44 0 .74-.11.91-.3m-.41-.71l.09.11c-.01.1-.04.11-.09.13h-.04l-.19.02c-.46 0-1.17-.19-1.9-.51.09-.1.13-.1.23-.1 1.4 0 1.8.25 1.9.35M8.83 17c-.65 1.19-1.24 1.85-1.69 2 .05-.38.5-1.04 1.21-1.69l.48-.31m3.02-6.91c-.23-.9-.24-1.63-.07-2.05l.07-.12.15.05c.17.24.19.56.09 1.1l-.03.16-.16.82-.05.04z"/></svg></a></li><li class="menuitemfolded"><a href="javascript:void(0);" title="Fold/unfold all" rel="nofollow" class="fold_unfold_all_new" onclick="fold_unfold_all();"><span>Fold/unfold all</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M 2,0 L 6.5,3 L 2,6 z M 8,6.6 L 12.5,9.6 L 8,12.6 z M 14,13.2 L 20,13.2 L 17,17.7 z"/></svg></a></li><li class="menuitem"><a href="start.html" title="Rename Page" rel="nofollow" class=" plugin_move_page "><span>Rename Page</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M18,4V3A1,1 0 0,0 17,2H5A1,1 0 0,0 4,3V7A1,1 0 0,0 5,8H17A1,1 0 0,0 18,7V6H19V10H9V21A1,1 0 0,0 10,22H12A1,1 0 0,0 13,21V12H21V4H18Z" /></svg></a></li><li class="siteexport_addpage"><a href="start.html" title="Export Page to HTML/PDF" rel="nofollow"><span>Export Page to HTML/PDF</span><svg width="61px" height="51px" viewBox="0 0 61 51" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs></defs><path d="M26.1891503,39.0065635 L26.0876578,38.9773206 L60.6523866,1.23972885 L60.4321374,2.11844376 L60.476442,2.07071678 L60.4265202,2.14085429 L49.5024876,45.7237994 L32.8255882,40.9187101 L26,50.508302 L26,39.2103249 L26.1891503,39.0065635 Z M60.9727675,0.862917243 L22.2676619,38.2155059 L-0.00245042233,30.2214566 L60.9727675,0.862917243 Z" id="Paper-Plane"></path></svg></a></li><li class="top"><a href="#dokuwiki__top" title="Back to top [t]" rel="nofollow" accesskey="t"><span>Back to top</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"/></svg></a></li>                    </ul>
                </div>
                        </div>
-->
        </div><!-- /wrapper -->

        
<!-- ********** FOOTER ********** -->
<!--
<div id="dokuwiki__footer"><div class="pad">
    
    <div class="buttons">
                <a href="https://www.dokuwiki.org/donate" title="Donate" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-donate.gif" width="80" height="15" alt="Donate" /></a>
        <a href="https://php.net" title="Powered by PHP" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-php.gif" width="80" height="15" alt="Powered by PHP" /></a>
        <a href="../../check/referer" title="Valid HTML5" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-html5.png" width="80" height="15" alt="Valid HTML5" /></a>
        <a href="../../css-validator/check/referer.fe4c581d16fb9f59f07485ddb441e467" title="Valid CSS" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-css.png" width="80" height="15" alt="Valid CSS" /></a>
        <a href="https://dokuwiki.org/" title="Driven by DokuWiki" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-dw.png" width="80" height="15"
            alt="Driven by DokuWiki" /></a>
    </div>
</div></div>
-->
    </div></div><!-- /site -->

    <div class="no"><img src="../../lib/exe/taskrunner.8b6c90beb70957655a689c7ea8f922cd.gif" width="2" height="1" alt="" /></div>
    <div id="screen__mode" class="no"></div></body>
</html>
